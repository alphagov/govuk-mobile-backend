name: Release candidate

on:
  workflow_dispatch:
  push:

defaults:
  run:
    shell: bash

jobs:
  ci:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      id-token: write
      contents: read
      pull-requests: write
      statuses: write
      checks: write
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Shallow clones should be disabled for a better relevancy of analysis

      - name: Set up SAM cli
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - uses: actions/setup-node@v3
        with:
          node-version: 22
          cache: 'npm'

      - uses: actions/setup-python@v4
        with:
          python-version: 3.8
      - run: pip install checkov

      - run: npm ci

      - uses: nrwl/nx-set-shas@v4

      - name: Create report directories
        run: |
          mkdir -p reports/source reports/infrastructure

      - name: Build
        run: npm run build:affected

      - name: SAM validate (with JUnit output)
        run: npm run validate:all #Aware this is not affected here, avoids script overwriting results.

      - name: Lint (with JUnit output)
        run: |
          # ESLint with JUnit formatter
          npx nx affected -t lint --quiet --format=junit --output-file=reports/source/lint-results.xml

      - name: Unit Test (with JUnit output)
        env:
          CI: true
        run: |
          # Vitest will use CI environment to output JUnit XML
          npx nx affected -t test:unit

      - name: Checkov scan (with JUnit output)
        run: |
          # Checkov with JUnit XML output
          npx nx affected -t checkov --skip-check CKV_AWS_73,CKV_AWS_115,CKV_AWS_116,CKV_AWS_117,CKV_AWS_120 --external-checks-dir ./.checkov --output junitxml --output-file-path reports/infrastructure

      - name: Coverage (with JUnit output)
        env:
          CI: true
        run: |
          # Coverage analysis
          if npm run test:coverage; then
            # Create simple JUnit XML for coverage results
            cat > reports/source/coverage-results.xml << EOF
            <?xml version="1.0" encoding="UTF-8"?>
            <testsuites name="Coverage Analysis">
              <testsuite name="Test Coverage" tests="1" failures="0" errors="0" skipped="0" time="1">
                <testcase name="Coverage Analysis" classname="Coverage.Analysis"/>
              </testsuite>
            </testsuites>
          EOF
          else
            cat > reports/source/coverage-results.xml << EOF
            <?xml version="1.0" encoding="UTF-8"?>
            <testsuites name="Coverage Analysis">
              <testsuite name="Test Coverage" tests="1" failures="1" errors="0" skipped="0" time="1">
                <testcase name="Coverage Analysis" classname="Coverage.Analysis">
                  <failure message="Coverage analysis failed">Test coverage analysis failed</failure>
                </testcase>
              </testsuite>
            </testsuites>
          EOF
            exit 1
          fi

      # Publish Source Code Test Results
      - name: Publish Source Code Test Results
        uses: mikepenz/action-junit-report@v4
        if: always()
        with:
          report_paths: 'reports/source/*.xml'
          check_name: 'ðŸ§ª Source Code Tests'
          summary: 'Source Code Quality & Testing Results'
          fail_on_failure: true
          include_passed: true
          detailed_summary: true
          annotate_notice_on_failure: true
          job_summary: true

      # Publish Infrastructure Test Results
      - name: Publish Infrastructure Test Results
        uses: mikepenz/action-junit-report@v4
        if: always()
        with:
          report_paths: 'reports/infrastructure/**/*.xml'
          check_name: 'ðŸ—ï¸ Infrastructure Tests'
          summary: 'CloudFormation & Security Scan Results'
          fail_on_failure: true
          include_passed: true
          detailed_summary: true
          annotate_notice_on_failure: true
          job_summary: true

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.qualitygate.wait=true
            -Dsonar.qualitygate.timeout=300
            ${{ github.event_name == 'pull_request' && format('-Dsonar.pullrequest.key={0} -Dsonar.pullrequest.branch={1} -Dsonar.pullrequest.base={2}', github.event.number, github.head_ref, github.base_ref) || '' }}

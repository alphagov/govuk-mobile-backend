#!/bin/bash

# Fetch CloudFormation stack outputs for one or more stacks and write them to a .env file.
# Each output key will be prefixed with 'CFN_'.

set -euo pipefail

ENV_FILE_PATH="${1:-.env}"
shift || true

if [ $# -lt 1 ]; then
  echo "Usage: $0 <output_env_file_path> <stack_name_1> [stack_name_2 ...]"
  echo "Example: $0 .env govuk-app-backend govuk-chat-backend"
  exit 1
fi

if ! touch "$ENV_FILE_PATH" 2>/dev/null; then
  echo "Error: Cannot write to $ENV_FILE_PATH"
  exit 1
fi

echo "Writing outputs to ${ENV_FILE_PATH}"

# Seed with static env values if present
if [ -f .env.static ]; then
  echo "Including .env.static contents"
  cat .env.static > "$ENV_FILE_PATH"
else
  # Truncate/create empty file
  : > "$ENV_FILE_PATH"
fi

# Add marker and timestamp
{
  echo ""
  echo "# Generated by scripts/get-cloudformation-outputs.sh on $(date -u +%FT%TZ)"
  echo ""
} >> "$ENV_FILE_PATH"

command -v aws >/dev/null 2>&1 || { echo "Error: AWS CLI is not installed."; exit 1; }
command -v jq >/dev/null 2>&1 || { echo "Error: jq is not installed."; exit 1; }

for STACK_NAME in "$@"; do
  echo "Fetching outputs for stack: ${STACK_NAME}"
  STACK_OUTPUTS=$(aws cloudformation describe-stacks \
    --stack-name "$STACK_NAME" \
    --query 'Stacks[0].Outputs[]' \
    --output json 2>/dev/null || true)

  if [ -z "$STACK_OUTPUTS" ] || [ "$STACK_OUTPUTS" = "[]" ]; then
    echo "Warning: No outputs found for stack '${STACK_NAME}'. Skipping."
    continue
  fi

  echo "# ${STACK_NAME}" >> "$ENV_FILE_PATH"
  echo "$STACK_OUTPUTS" | jq -r '.[] | "CFN_\(.OutputKey)=\(.OutputValue)"' >> "$ENV_FILE_PATH"
  echo "" >> "$ENV_FILE_PATH"
done

echo "Done. You can now source ${ENV_FILE_PATH}"


